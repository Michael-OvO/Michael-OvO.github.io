<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>C++题解 on Michael's blog</title><link>https://michael-ovo.github.io/categories/c++%E9%A2%98%E8%A7%A3/</link><description>Recent content in C++题解 on Michael's blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 27 Oct 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://michael-ovo.github.io/categories/c++%E9%A2%98%E8%A7%A3/index.xml" rel="self" type="application/rss+xml"/><item><title>CF384A</title><link>https://michael-ovo.github.io/p/cf384a/</link><pubDate>Wed, 27 Oct 2021 00:00:00 +0000</pubDate><guid>https://michael-ovo.github.io/p/cf384a/</guid><description>CF384A 洛谷传送门
原题传送门
本菜鸡的第 $99$ 道橙题，心血来潮写一篇题解。
题意 一种棋的规则是：在一个棋盘中，与该棋子相邻的上，下，左，右，$4$ 个格子中不能有棋子出现。
给出一个 $n \times n$ 的棋盘，首先输出在这个棋盘中最多能放多少个棋子，并输出一种最大的可行的摆放方案。
解法$1$ 纯暴力模拟 通过画图观察规律。
$$n=2$$
C. .C $$n=3$$
C.C .C. C.C $$n=4$$
C.C. .C.C C.C. .C.C $$n=5$$
C.C.C .C.C. C.C.C .C.C. C.C.C 我们发现，当坐标为第偶数行，偶数列时落子，或者在第奇数行，第奇数列落子，得到的一定是最优解。
那么就可以根据这个思路通过创建一个二维字符组模拟棋子摆放的过程。 因为 $n$ 的数据范围很小，所以这样的方法虽然时间复杂度较高，但是也是可行的。
第一种解法代码 #include&amp;lt;bits/stdc++.h&amp;gt; using namespace std; char board[2000][2000];//存储棋盘状态 int cnt; int main() { ios::sync_with_stdio(0); cin.tie(0); int n; cin&amp;gt;&amp;gt;n; //i代表行,j代表列 for(int i=1;i&amp;lt;=n;i++){ for(int j=1;j&amp;lt;=n;j++){ if((i%2&amp;amp;&amp;amp;j%2)||!(i%2^j%2))board[i][j]=&amp;#39;C&amp;#39;,cnt++; //判断是否可以落子 else board[i][j]=&amp;#39;.&amp;#39;;//否则不下子 } } cout&amp;lt;&amp;lt;cnt&amp;lt;&amp;lt;endl; for(int i=1;i&amp;lt;=n;i++){ for(int j=1;j&amp;lt;=n;j++){ cout&amp;lt;&amp;lt;board[i][j]; //输出棋盘 } cout&amp;lt;&amp;lt;endl; } } 解法 $2$ 优化暴力 但是刚刚的解法需要先存储，再输出一遍，比较浪费时间，还是有可以优化的空间。</description></item><item><title>CF899b</title><link>https://michael-ovo.github.io/p/cf899b/</link><pubDate>Wed, 27 Oct 2021 00:00:00 +0000</pubDate><guid>https://michael-ovo.github.io/p/cf899b/</guid><description>CF899B Months and Years 原题传送门
洛谷传送门
这可能是目前最暴力的一篇题解了。。
题目其实很简单，给出几个连续月份的天数，判断是否合法
好端端的一道模拟题就这么被打表暴力过了
不过确实，与其说写一堆复杂的判断和模拟，打表所需的代码量少之又少。
思路 首先自己创建好连续几年（需要包含平年和闰年的数据，因为题目中的月份数最多会达到 $24$）每个月天数的数据。
&amp;#34;31 28 31 30 31 30 31 31 30 31 30 31 31 28 31 30 31 30 31 31 30 31 30 31 31 29 31 30 31 30 31 31 30 31 30 31 31 28 31 30 31 30 31 31 30 31 30 31 31 28 31 30 31 30 31 31 30 31 30 31 &amp;#34; 随后，我们只需要原封不动的读入字符串，再用 find() 函数直接判断是否为我们提前创建好的字符串中的一个子串即可。</description></item></channel></rss>